### 1. 请你说说innodb和myisam的区别？

事务、锁、读写性能、存储结构 

标准回答 InnoDB是具有事务、回滚和崩溃修复能力的事务安全型引擎,它可以实现行级锁来保证高性能的大量数据中的并发操作；

MyISAM是具有默认支持全文索引、压缩功能及较高查询性能的非事务性引擎。具体来说,可以在以下角度上形成对比： 事务：InnoDB支持事务；MyISAM不支持。 

数据锁：InnoDB支持行级锁；MyISAM只支持表级锁。 读写性能：InnoDB增删改性能更优；MyISAM查询性能更优。 全文索引：InnoDB不支持（但可通过插件等方式支持）；MyISAM默认支持。 外键：InnoDB支持外键；MyISAM不支持。 存储结构：InnoDB在磁盘存储为一个文件；MyISAM在磁盘上存储成三个文件（表定义、数据、索引）。 

存储空间：InnoDB需要更多的内存和存储；MyISAM支持支持三种不同的存储格式：静态表(默认)、动态表、压缩表。 移植：InnoDB在数据量小时可通过拷贝数据文件、备份 binlog、mysqldump工具移植,数据量大时比较麻烦；可单独对某个表通过拷贝表文件移植。 崩溃恢复：InnoDB有崩溃恢复机制；MyISAM没有。 默认推荐：InnoDB是MySQL5.5之后的默认引擎。 加分回答 InnoDB中行级锁是怎么实现的？ InnoDB行级锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据,InnoDB才使用行级锁,否则,InnoDB将使用表锁。 当表中锁定其中的某几行时,不同的事务可以使用不同的索引锁定不同的行。另外,不论使用主键索引、唯一索引还是普通索引,InnoDB都会使用行锁来对数据加锁。



### 2. string、StringBuffer、Stringbuilder有什么区别

字符串是否可变,StringBuffer、StringBuilder线程安全问题 标准回答 Java中提供了String,StringBuffer两个类来封装字符串,并且提供了一系列方法来操作字符串对象。 

String是一个不可变类,也就是说,一个String对象创建之后,直到这个对象销毁为止,对象中的字符序列都不能被改变。

 StringBuffer对象则代表一个字符序列可变的字符串,当一个StringBuffer对象被创建之后,我们可以通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()、等方法来改变这个字符串对象的字符序列。

当通过StringBuffer得到期待中字符序列的字符串时,就可以通过toString()方法将其转换为String对象。

StringBuilder类是JDK1.5中新增的类,他也代表了字符串对象。和StringBuffer类相比,它们有共同的父类`AbstractStringBuilder`,二者无论是构造器还是方法都基本相同,不同的一点是,StringBuilder没有考虑线程安全问题,也正因如此,StringBuilder比StringBuffer性能略高。因此,如果是在单线程下操作大量数据,应优先使用StringBuilder类；如果是在多线程下操作大量数据,应优先使用StringBuilder类。



### 3.请你说说HashMap底层原理?

数据结构、put()流程、扩容机制 

标准回答 数据结构 在JDK8中,HashMap底层是采用“数组+链表+红黑树”来实现的。 

HashMap是基于哈希算法来确定元素的位置（槽）的,当我们向集合中存入数据时,它会计算传入的Key的哈希值,并利用哈希值取余来确定槽的位置。

如果元素发生碰撞,也就是这个槽已经存在其他的元素了,则HashMap会通过链表将这些元素组织起来。

如果碰撞进一步加剧,某个链表的长度达到了8,则HashMap会创建红黑树来代替这个链表,从而提高对这个槽中数据的查找的速度。 

HashMap中,数组的默认初始容量为16,这个容量会以2的指数进行扩容。具体来说,当数组中的元素达到一定比例的时候HashMap就会扩容,这个比例叫做负载因子,默认为0.75。

自动扩容机制,是为了保证HashMap初始时不必占据太大的内存,而在使用期间又可以实时保证有足够大的空间。采用2的指数进行扩容,是为了利用位运算,提高扩容运算的效率。

 put()流程 put()方法的执行过程中,主要包含四个步骤： 

1. 判断数组,若发现数组为空,则进行首次扩容。
2.  判断头节点,若发现头节点为空,则新建链表节点,存入数组。
3.  判断头节点,若发现头节点非空,则将元素插入槽内。 
4. 插入元素后,判断元素的个数,若发现超过阈值则再次扩容。 其中,第3步又可以细分为如下三个小步骤： 1. 若元素的key与头节点一致,则直接覆盖头节点。 2. 若元素为树型节点,则将元素追加到树中。 3. 若元素为链表节点,则将元素追加到链表中。追加后,需要判断链表长度以决定是否转为红黑树。若链表长度达到8、数组容量未达到64,则扩容。若链表长度达到8、数组容量达到64,则转为红黑树。 扩容机制 向HashMap中添加数据时,有三个条件会触发它的扩容行为： 1. 如果数组为空,则进行首次扩容。 2. 将元素接入链表后,如果链表长度达到8,并且数组长度小于64,则扩容。 3. 添加后,如果数组中元素超过阈值,即比例超出限制（默认为0.75）,则扩容。 并且,每次扩容时都是将容量翻倍,即创建一个2倍大的新数组,然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N,所以可以用位移运算计算新容量,效率很高。 加分回答 HashMap是非线程安全的,在多线程环境下,多个线程同时触发HashMap的改变时,有可能会发生冲突。所以,在多线程环境下不建议使用HashMap,可以考虑使用Collections将HashMap转为线程安全的HashMap,更为推荐的方式则是使用ConcurrentHashMap。

### 4.说说你了解的JVM内存模型?

类加载子系统、执行引擎、运行时数据区 标准回答 JVM由三部分组成：类加载子系统、执行引擎、运行时数据区。 

1. 类加载子系统,可以根据指定的全限定名来载入类或接口。 
2.  执行引擎,负责执行那些包含在被载入类的方法中的指令。
3.  当程序运行时,JVM需要内存来存储许多内容,例如：字节码、对象、参数、返回值、局部变量、运算的中间结果,等等,JVM会把这些东西都存储到运行时数据区中,以便于管理。而运行时数据区又可以分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。 加分回答 运行时数据区是开发者重点要关注的部分,因为程序的运行与它密不可分,很多错误的排查也需要基于对运行时数据区的理解。在运行时数据区所包含的几块内存空间中,方法区和堆是线程之间共享的内存区域,而虚拟机栈、本地方法栈、程序计数器则是线程私有的区域,就是说每个线程都有自己的这个区域。

### 5. 说说JVM的垃圾回收机制?

新生代收集、老年代收集、混合收集、整堆收集 

标准回答 当前商业虚拟机的垃圾收集器,大多数都遵循了“分代收集”的理论进行设计,分代收集名为理论,实质是一套符合大多数程序运行实际情况的经验法则。

而分代收集理论,建立在如下三个分代假说之上,即弱分代假说、强分代假说、跨代引用假说。依据分代假说理论,垃圾回收可以分为如下几类： 

1. 新生代收集：目标为新生代的垃圾收集。 
2. 老年代收集：目标为老年代的垃圾收集,目前只有CMS收集器会有这种行为。 
3.  混合收集：目标为整个新生代及部分老年代的垃圾收集,目前只有G1收集器会有这种行为。 
4. 整堆收集：目标为整个堆和方法区的垃圾收集。 加分回答 HotSpot虚拟机内置了很多垃圾收集器,其中针对新生代的垃圾收集器有Serial、ParNew、Parallel Scavenge,针对老年代的垃圾收集器有CMS、Serial Old、Parallel Old。此外,HotSpot还内置了面向整堆的G1收集器。在上述收集器中,常见的组合方式有： 1. Serial + Serial Old,是客户端模式下常用的收集器。 2. ParNew + CMS,是服务端模式下常用的收集器。 3. Parallel Scavenge + Parallel Old,适用于后台运算而不需要太多交互的分析任务。



### 6. 说说类加载机制?

标准回答

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析三个部分统称为连接，而前五个阶段则是类加载的完整过程。

1. 在加载阶段JVM需要在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。
2. 验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
3. 准备阶段是正式为类中定义变量（静态变量）分配到内存并设置类变量初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域。
4.  解析阶段是Java虚拟机将常量池内的符号替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，直接引用是可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。
5. 类的初始化阶段是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。本质上，初始化阶段就是执行类构造器`<clinit>()`的过程。`<clinit>()`并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。

### 7.epoll原理?

epoll是一种更加高效的IO复用技术，epoll的使用步骤及原理如下：先调用epoll_create()在内核创建 epoll对象，其中有两个重要的成员，一个是需要检测的文件描述符的信息struct_rootrbr（红黑树），还有一个是就绪列表struct_list_head_rdlist，存放检测到数据发送改变的文件描述符信息(双向链表)； 再调用epoll_ctrl（）可以向epoll对象中添加，删除，修改要监听的文件描述符及事件， 再调用epoll_wait（）可以让内核去检测就绪的事件，并将就绪的事件放到就绪列表中并返回，通过返回事件数组做进一步的事件处理。 epoll有两种工作模式：LT 模式（水平触发）level_Triggered 是缺省的工作方式，能同时支持Block 和 Nonblock Soceket, 在这种做法中，内核检测到一个文件描述符就绪了，然后可以对这个就绪的fd进行io操作，如果不作任何操作，内核还是会继续通知。 2 ET（边沿触发）模式(Edge-Triggered)是高速工作方式，只支持Nonblock socket. 这种模式下，当描述符从未就绪变成就绪时，内核通过epoll检测到，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了，但是如果一直不对这个fd进行io操作（从而导致它再次变成未就绪状态了），内核不会发送更多的通知（only once），ET 模式很大程度上减少epoll事件被重复触发的次数，因此效率比LT 模式要高， epoll 工作再ET模式下的时候必须使用非阻塞套接字，以避免一个文件描述符的阻塞读/阻塞写操作把 处理多个文件描述符的任务饿死。





### 8. 请你说一下抽象类和接口的区别?

 接口与抽象类的方法,接口与抽象类的常量与变量,单继承多实现 

标准答案 接口和抽象类相同点有：

 - 接口和抽象类都不能被实例化,它们都位于继承树的顶端,用于被其它类实现和继承 - 接口和抽象类都可以有抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法 在用法上,接口和抽象类也有如下差异： - 接口里只能包含抽象方法和默认方法,不能为普通方法提供方法实现；抽象类则可以包含普通方法。 - 接口里只能定义静态常量,不能定义普通成员变量；抽象类里既可以定义普通成员变量,也可以定义静态常量 - 接口里不包含构造器；抽象类可以包含构造器,但抽象类的构造器并不是用于创建对象,而是让其子类调用这些构造器来完成属于抽象类的初始化操作 - 接口里不能包含初始化块,抽象类则可以包含初始化块 - 一个类最多只能有一个父类,包括抽象类；但一个类可以直接实现多个接口,通过实现多个接口可以弥补Java单继承的不足 总之,接口通常是定义允许多个实现的类型的最佳途径,但当演变的容易性比灵活性和功能更加重要时,应该使用抽象类来定义类型。 加分回答 在二者的设计目的上,接口作为系统与外界交互的窗口,体现了一种规范。对于接口的实现者来说,接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言,接口规定了调用者可以调用哪些服务,以及如何调用这些服务。当在一个程序中使用接口时,接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时,接口是多个程序之间的通信标准。 抽象类则不一样,抽象类作为系统中多个子类的共同父类,它体现的是一种模板式设计。抽象类作为多个子类的父类,它可以被当作系统实现过程中的中间产品,这个中间产品已经实现了系统的部分功能,但这个产品依然不能当作最终产品,必须要有更进一步的完善。这种完善可能有几种不同方式。





### 9. 请你说说==与equals()的区别?

== 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。 equals() 没有重写时，Object默认以==来实现，即比较两个对象的内存地址是否相等； 重写以后，按照对象的内容进行比较。





### 10. 说说synchronize的用法及原理?

synchronized可以修饰静态方法、普通方法、代码块。 能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。 synchronized作用在代码块时，它的底层是通过monitorenter、monitorexit指令来实现的。



### 11. 说说你对AQS的理解?

模板方法、同步队列、同步状态 标准回答 AQS（AbstractQueuedSynchronizer）是队列同步器,是用来构建锁的基础框架,Lock实现类都是基于AQS实现的。

AQS是基于模板方法模式进行设计的,所以锁的实现需要继承AQS并重写它指定的方法。

AQS内部定义了一个FIFO的队列来实现线程的同步,同时还定义了同步状态来记录锁的信息。 AQS的模板方法,将管理同步状态的逻辑提炼出来形成标准流程,这些方法主要包括：独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态。以独占式获取同步状态为例,它的大致流程是：

1. 尝试以独占方式获取同步状态。

2. 如果状态获取失败,则将当前线程加入同步队列。

3. 自旋处理同步状态,如果当前线程位于队头,则唤醒它并让它出队,否则使其进入阻塞状态。 其中,有些步骤无法在父类确定,则提炼成空方法留待子类实现。例如,第一步的尝试操作,对于公平锁和非公平锁来说就不一样,所以子类在实现时需要按照场景各自实现这个方法。 AQS的同步队列,是一个双向链表,AQS则持有链表的头尾节点。对于尾节点的设置,是存在多线程竞争的,所以采用CAS的方式进行修改。对于头节点设置,则一定是拿到了同步状态的线程才能处理,所以修改头节点不需要采用CAS的方式。 AQS的同步状态,是一个int类型的整数,它在表示状态的同时还能表示数量。通常情况下,状态为0时表示无锁,状态大于0时表示锁的重入次数。另外,在读写锁的场景中,这个状态标志既要记录读锁又要记录写锁。于是,锁的实现者就将状态表示拆成高低两部分,高位存读锁、低位存写锁。 加分回答 同步状态需要在并发环境下修改,所以需要保证其线程安全。由于AQS本身就是锁的实现工具,所以不适合用锁来保证其线程安全,因为如果你用一个锁来定义另一个锁的话,那干脆直接用synchronized算了。实际上,同步状态是被volatile修饰的,该关键字可以保证状态变量的内存可见性,从而解决了线程安全问题。 加分回答 同步状态需要在并发环境下修改,所以需要保证其线程安全。由于AQS本身就是锁的实现工具,所以不适合用锁来保证其线程安全,因为如果你用一个锁来定义另一个锁的话,那干脆直接用synchronized算了。实际上,同步状态是被volatile修饰的,该关键字可以保证状态变量的内存可见性,从而解决了线程安全问题。

### 12. Java哪些地方使用了CAS?

 原子类、AQS、并发容器 标准回答 Java提供的API中使用CAS的地方有很多,比较典型的使用场景有原子类、AQS、并发容器。 对于原子类,以AtomicInteger为例,它的内部提供了诸多原子操作的方法。如原子替换整数值、增加指定的值、加1,这些方法的底层便是采用操作系统提供的CAS原子指令来实现的。 对于AQS,在向同步队列的尾部追加节点时,它首先会以CAS的方式尝试一次,如果失败则进入自旋状态,并反复以CAS的方式进行尝试。此外,在以共享方式释放同步状态时,它也是以CAS方式对同步状态进行修改的。 对于并发容器,以ConcurrentHashMap为例,它的内部多次使用了CAS操作。在初始化数组时,它会以CAS的方式修改初始化状态,避免多个线程同时进行初始化。在执行put方法初始化头节点时,它会以CAS的方式将初始化好的头节点设置到指定槽的首位,避免多个线程同时设置头节点。在数组扩容时,每个线程会以CAS方式修改任务序列号来争抢扩容任务,避免和其他线程产生冲突。在执行get方法时,它会以CAS的方式获取头指定槽的头节点,避免其他线程同时对头节点做出修改。 加分回答 CAS的实现离不开操作系统原子指令的支持,Java中对原子指令封装的方法集中在Unsafe类中,包括：原子替换引用类型、原子替换int型整数、原子替换long型整数。这些方法都有四个参数：var1、var2、var4、var5,其中var1代表要操作的对象,var2代表要替换的成员变量,var4代表期望的值,var5代表更新的值。 public final native boolean compareAndSwapObject( Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt( Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong( Object var1, long var2, long var4, long var6);



### 13. 说说JVM的垃圾回收算法?

1.引用计数法，每次赋值时均要维护引用计数器且计数器本身也有一定的消耗，较难处理循环引用，一般不采用这种方式；
2.复制算法，将内存分为两块，每次只使用其中一块，当这块内存用完，就将还活着的对象复制到另外一块上面，效率高且没有碎片，但是需要双倍的空间，年轻代中使用复制算法；
3.标记-清除，先标记要清除的对象，然后统一回收这些对象，不需要额外的空间，但是需要两次扫描耗时严重并且会产生内存碎片；
4.标记-整理，标记存活对象，然后将标记的存活对象按内存地址依次排序，清除边界外未标记的对象，没有内存碎片，但是需要移动对象。老年代一般用标记-清除和标记-整理的混合实现。

### 14. 请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？

得分点 有序无序、底层结构 标准回答 Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数 ( score ) 却可以重复。集合是通过哈希表实现的,所以添加,删除,查找的复杂度都是 O(1)。集合中最大的成员数为 2^32 – 1 ( 4294967295 ) , 每个集合可存储 40 多亿个成员。 zset底层的存储结构包括ziplist或skiplist,在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist,其他时候使用skiplist。 当ziplist作为zset的底层存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值。 当skiplist作为zset的底层存储结构的时候,使用skiplist按序保存元素及分值,使用dict来保存元素和分值的映射关系。 加分回答 实际上单独使用Hashmap或skiplist也可以实现有序集合,Redis使用两种数据结构组合的原因是如果我们单独使用Hashmap,虽然能以O

(1) 的时间复杂度查找成员的分值,但是因为Hashmap是以无序的方式来保存集合元素,所以每次进行范围操作的时候都要进行排序；而如果单独使用skiplist,虽然能执行范围操作,但查找操作的复杂度却由 O(1)变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。



### 15. 说说static修饰符的用法?

static可修饰类，方法，代码块，变量。不可以修饰构造器。

 被static修饰的类为静态类，可以在不创建实例的情况下访问它的静态方法或静态成员变量，而其实例方法或实例成员变量只能通过其实例对象来访问。

 在静态方法中不能使用this，因为this是随着对象创建而存在。 

 静态成员变量随着静态类的加载而创建。



